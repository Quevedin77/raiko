use axum::{body::Body, debug_handler, http::header, response::Response, routing::get, Router};
use prometheus::{Encoder, TextEncoder};
use utoipa::OpenApi;

use crate::{error::HostResult, ProverState};

#[utoipa::path(
    get,
    path = "/metrics",
    tag = "Metrics",
    responses (
        (status = 200, description = "The metrics have been captured successfuly", body = Body),
    ),
)]
#[debug_handler(state = ProverState)]
/// Get prometheus metrics
///
/// Currently available metrics are:
/// - concurrent_requests - the number of proof requests currently being served
/// - host_request_count - the number of requests sent to this machine in total
/// - host_error_count - the number of requests failed outside of guest execution
/// - guest_proof_request_count - the number of requests sent to this guest
/// - guest_proof_success_count - the number of successful proofs generated by this guest
/// - guest_proof_error_count - the number of failed proofs generated by this guest
/// - guest_proof_time_gauge - time taken for proof generation by this guest
/// - prepare_input_time_histogram - time taken for prepare input
async fn handler() -> HostResult<Response> {
    let encoder = TextEncoder::new();
    let mut buffer = vec![];
    let mf = prometheus::gather();
    encoder.encode(&mf, &mut buffer).unwrap();

    Response::builder()
        .header(header::CONTENT_TYPE, encoder.format_type())
        .body(Body::from(buffer))
        .map_err(|e| anyhow::anyhow!(e).into())
}

#[derive(OpenApi)]
#[openapi(paths(handler))]
struct Docs;

pub fn create_docs() -> utoipa::openapi::OpenApi {
    Docs::openapi()
}

pub fn create_router() -> Router<ProverState> {
    Router::new().route("/", get(handler))
}
